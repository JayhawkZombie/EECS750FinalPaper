%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%

% \documentclass[10pt,journal,cspaper,compsoc]{IEEEtran}   %%%tc version
\documentclass[10pt, conference]{IEEEtran}
%\documentclass[conference,compsoc]{IEEEtran}
%\documentclass[10pt, conference]{IEEEtran}
%\documentclass[times, 10pt,onecolumn]{article}
\usepackage{amsmath, amssymb, enumerate}

%%%%%%%%%%%%%%%% page control%%%%%%%%%%%%%%%%%
%\usepackage[margin=0.75in]{geometry}

%\linespread{0.991}  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% this is really useful
%\usepackage{cite}
\usepackage{fancybox}
\usepackage{amsfonts}
%\usepackage{algorithm}
%\usepackage[noend]{algorithmic}
\usepackage[usenames]{color}
%\usepackage{colortbl}
%\usepackage[ figure, boxed, vlined]{algorithm2e}
%\usepackage[linesnumbered,vlined]{algorithm2e}
%\usepackage[lined,boxed]{algorithm2e}
\usepackage{listings}

\usepackage[linesnumbered,vlined]{algorithm2e}
\usepackage{graphicx}
\usepackage{times}
\usepackage{psfrag}
\usepackage{subfigure}
\usepackage{caption}
%\usepackage{subcaption}
\usepackage{multirow}
%\usepackage{setspace}
%\usepackage{listings}
\usepackage{epsfig}
%\usepackage{epstopdf}
%\usepackage[font=small,labelfont=bf]{caption}
\usepackage{url}
\usepackage{float}

\usepackage{color}
\def\fixme#1{\typeout{FIXED in page \thepage : {#1}}
%\bgroup \color{red}{} \egroup}
\bgroup \color{red}{[FIXME: {#1}]} \egroup}

%\usepackage[pdftex]{hyperref}
\usepackage{rotating,tabularx}

\interfootnotelinepenalty=10000

%% Define a new 'leo' style for the package that will use a smaller font.
\makeatletter
\def\url@leostyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother

%\documentstyle[times,art10,twocolumn,latex8]{article}

%-------------------------------------------------------------------------
% take the % away on next line to produce the final camera-ready version
\pagestyle{plain}
%\thispagestyle{empty}
%\pagestyle{empty}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}

%% remaining budget share, used in task stall section.
\newcommand{\bottomrule}{\hline}
\newcommand{\toprule}{\hline}
\newcommand{\midrule}{\hline}

%-------------------------------------------------------------------------
\begin{document}

\title{The Linux Scheduler: Complicatedly Simple Calculations}
\author{Kurt Slagle, Dustin Hauptman\\
\{kslagle,dhauptman\}@ku.edu\\
University of Kansas, USA\\ 
}

\maketitle
\thispagestyle{empty}
\begin{abstract}

\textbf{The Linux scheduler is written to be adaptive, flexible, and customizable.  However, with this modularity comes complexity.  As the kernel cannot easily perform floating point computations, there are present, inside the scheduler's per-task computations, a number of operations that are seemingly overly complex in an attempt to reproduce the floating point operations using fixed-point operations.  This paper looks in-depth at one function called repeatedly inside the kernels Completely Fair Scheduler, and presents a statistical analysis of the values passed to and from this function, as well as the accuracy of the performed computations.}

\end{abstract}

%-------------------------------------------------------------------------

\section{Introduction}

\definecolor{commentgreen}{rgb}{0,0.4,0}
\lstset{
	language=C, 
	basicstyle=\footnotesize, 
	breaklines=true, 
	keywordstyle=\color{blue},
	commentstyle=\color{commentgreen},
	emph={int,u32,u64,load_weight,mul_u64_u32_shr},
	emphstyle=\color{blue}
}

For newcomers to the Linux kernel, it would not be difficult to find oneself struggling to understand why a piece of code is written the way that it is.  Comments in the source code are often detailed, but do not always explain the choices that influenced the implementation of a function.  Floating point calculations are disabled inside the kernel, and enabling them is not free from overhead, so the code in the kernel is written to avoid using them.  This code can often be difficult to follow, and it is not often clear why the code is written in that way.

When exploring the implementation of the Completely Fair Scheduler (CFS) in the Linux kernel, we were intrigued by the code used in $\_\_calc\_delta$ in $fair.c$.  The concept of the Completely Fair Scheduler (CFS) is deceptively simple.  The source code for this inside the Linux kernel appears, initially, far more complex than would seem necessary.  We suspected this code is written this way to help ensure the result of the calculation is correct on a variety of machines.  The code is optimized to perform well for a number of special cases, but this comes at the sacrifice of readability.

We hypothesize that this implementation could be simplified if it was assumed it was to be run on a 64-bit system.  In this paper, we present an discussion of the changes made, an analysis of the performance impacts of those changes, and an analysis of the accuracy of the values obtained from both implementations.  

\section{Background}
The Completely Fair Scheduler seeks to be "fair" to all processes running, weighting processes to provide more CPU to those processes with a high priority without starving lower-priority tasks.  Each task maintains a virtual time, which is equivalent to the execution time divided by its weight.  The focus of this paper is on the code inside $\_\_calc\_delta$, namely on the calculation of $delta\_exec * 1 / weight$.  Floating point math cannot be used to simplify this, since floating point operations are disabled in the kernel.  They can be enabled, but doing so would likely only prove to be a detriment to performance.

What can be considered is the removal of the special-case optimizations to improve readability.  $\_\_calc\_delta$ is intended to compute $delta\_exec * 1 / weight$, and the code for this in the default Linux kernel is shown in Figure~\ref{fig:figure1}.  The code shown simply calculates the new $delta\_exec$ by multiplying it with the weight and inverted load weight.  The purpose of implementing it in this way is not immediately clear and not elaborated on in detail.  We seek to analyze the benefits gained or lost by implementing the code in this way.

\begin{figure}[h]
	\centering
	\lstinputlisting{__calc_delta.c}
	\caption{\_\_calc\_delta in fair.c}
	\label{fig:figure1}
\end{figure}

For the aforementioned code, the accuracy of the calculation is determined by tracking the value computed by the kernel and the value computed by using floating point operations in user space.  This will be compared to the accuracy achieved by using a simpler version of the code, seen in Figure~\ref{fig:figure2}.
Because speed is critical inside the scheduler, the time spent inside both versions of the code is compared.  Since the kernel will perform different operations when using cgroups and not using cgroups for processes, the same analysis is done with benchmarks run with and without using cgroups.

The Linux kernel uses a plethora of macros whose values are configuration-dependent, and thus it should not be assumed that the analysis presented here is reflective of how the changes would perform on other system configurations.  The system on which this was tested is a Dell Latitude 5580, with an Intel Core i7 7820HQ @ 2.9 GHz (turbo up to 3.9 GHz), 16GB of DDR4 @ 2400 MHz memory, and 500GB HDD @ 7200 rpm.  To keep the CPU running at a relatively constant rate, dynamic frequency scaling was disabled.

\section{Your System}

The simplified form of the code is shown in Figure~\ref{fig:figure2}.

\begin{figure}[h]
	\centering
	\lstinputlisting{__calc_delta_new.c}
	\caption{Altered \_\_calc\_delta in fair.c}
	\label{fig:figure2}
\end{figure}

\section{Evaluation}
...
\section{Conclusion}
...
%-------------------------------------------------------------------------

\nocite{*}
\end{document}
